"""Type I polarized IKKT model."""

from __future__ import annotations

import os

import numpy as np
import torch

from MatrixModelHMC_pytorch import config
from MatrixModelHMC_pytorch.algebra import ad_matrix, get_eye_cached, get_trace_projector_cached
from MatrixModelHMC_pytorch.models.base import MatrixModel
from MatrixModelHMC_pytorch.models.utils import _commutator_action_sum


ENABLE_TORCH_COMPILE = config.ENABLE_TORCH_COMPILE


def _type1_logdet_impl(X: torch.Tensor, A: torch.Tensor) -> torch.Tensor:
    adX = 1j * ad_matrix(X[:4])
    adX1, adX2, adX3, adX4 = adX
    i = torch.tensor(1j, dtype=X.dtype, device=X.device)
    twoi = torch.tensor(2j, dtype=X.dtype, device=X.device)

    upper_left = -(adX3 + i * adX4)
    upper_right = -(adX1 - i * adX2)
    lower_left = -(adX1 + i * adX2)
    lower_right = adX3 - i * adX4

    C = torch.cat(
        (torch.cat((upper_left, lower_left), dim=1), torch.cat((upper_right, lower_right), dim=1)),
        dim=0,
    )

    AB = torch.cat(
        (
            torch.cat((twoi * lower_left, twoi * lower_right), dim=1),
            torch.cat((-twoi * upper_left, -twoi * upper_right), dim=1),
        ),
        dim=0,
    )

    K = -A - 0.25 * (C @ AB)

    # Lift zero modes from the trace sector (identity direction)
    # This adds a constant mass term to the trace mode, ensuring invertibility
    # without affecting the physics (since it's a constant factor in det).
    N = X.shape[-1]
    dim = N * N
    P = get_trace_projector_cached(N, K.device, K.dtype)
    K[:dim, :dim] += P
    K[dim:, dim:] += P

    det = torch.slogdet(K)
    return det


class PIKKTTypeIModel(MatrixModel):
    """Type I polarized IKKT model definition."""

    model_name = "pikkt4d_type1"

    def __init__(self, ncol: int, couplings: list, source: np.ndarray | None = None, no_myers: bool = False) -> None:
        super().__init__(nmat=4, ncol=ncol)
        self.couplings = couplings
        self.g = self.couplings[0]
        self.source = torch.diag(torch.tensor(source, device=config.device, dtype=config.dtype)) if source is not None else None
        self.no_myers = no_myers
        self.is_hermitian = True
        self.is_traceless = True

        dim_tr = self.ncol * self.ncol
        eye_tr = get_eye_cached(dim_tr, device=config.device, dtype=config.dtype)
        i = 1j
        two_i_I = (2 * i) * eye_tr
        A = torch.zeros((2 * dim_tr, 2 * dim_tr), device=config.device, dtype=config.dtype)
        A[:dim_tr, dim_tr:] = two_i_I
        A[dim_tr:, :dim_tr] = -two_i_I
        self._type1_A = A.clone()

        def base_fn(X: torch.Tensor, *, model=self) -> torch.Tensor:
            return _type1_logdet_impl(X, model._type1_A)

        if ENABLE_TORCH_COMPILE and hasattr(torch, "compile"):
            self._log_det_fn = torch.compile(base_fn, dynamic=False)
        else:
            self._log_det_fn = base_fn

    def load_fresh(self, args):
        X = torch.zeros((self.nmat, self.ncol, self.ncol), dtype=config.dtype, device=config.device)
        self.set_state(X)

    def potential(self, X: torch.Tensor | None = None) -> torch.Tensor:
        X = self._resolve_X(X)
        bos = -0.5 * _commutator_action_sum(X)
        trace_sq = torch.einsum("bij,bji->", X, X)
        bos = bos + trace_sq

        det = -0.5 * self._log_det_fn(X)[1].real
        src = torch.tensor(0.0, dtype=X.dtype, device=X.device)
        if self.source is not None:
            src = -(self.ncol / np.sqrt(self.g)) * torch.trace(self.source @ X[0])

        return (bos.real * (self.ncol / self.g)) + det + src.real

    def measure_observables(self, X: torch.Tensor | None = None):
        with torch.no_grad():
            X = self._resolve_X(X)
            eigs = []
            for i in range(self.nmat):
                e = torch.linalg.eigvalsh(X[i]).cpu().numpy()
                eigs.append(e)

            e_complex = torch.linalg.eigvals((X[0] + 1j * X[1])).cpu().numpy()
            eigs.append(e_complex)
            e_complex = torch.linalg.eigvals((X[2] + 1j * X[3])).cpu().numpy()
            eigs.append(e_complex)

            eigs.append(torch.linalg.eigvalsh(X[0] @ X[0] + X[1] @ X[1] + X[2] @ X[2]).cpu().numpy())

            C = X[0] @ X[1] - X[1] @ X[0]
            A = X[0] @ X[1] + X[1] @ X[0]
            c1 = torch.trace(C @ C).real
            c2 = torch.trace(A @ A).real
            C = X[2] @ X[3] - X[3] @ X[2]
            A = X[2] @ X[3] + X[3] @ X[2]
            c3 = torch.trace(C @ C).real
            c4 = torch.trace(A @ A).real

            corrs = torch.stack([c1, c2, c3, c4]).cpu().numpy()

        return eigs, corrs

    def build_paths(self, name_prefix: str, data_path: str) -> dict[str, str]:
        omega_suffix = f"_omega{round(self.omega, 4)}" if hasattr(self, "omega") else ""
        run_dir = os.path.join(
            data_path,
            f"{name_prefix}_{self.model_name}_g{round(self.g, 4)}{omega_suffix}_N{self.ncol}",
        )
        return {
            "dir": run_dir,
            "eigs": os.path.join(run_dir, "evals.npz"),
            "corrs": os.path.join(run_dir, "corrs.npz"),
            "meta": os.path.join(run_dir, "metadata.json"),
            "ckpt": os.path.join(run_dir, "checkpoint.pt"),
        }

    def status_string(self, X: torch.Tensor | None = None) -> str:
        X = self._resolve_X(X)
        trX1 = (torch.trace(X[0] @ X[0]) / self.ncol).item().real
        trX4 = (torch.trace(X[3] @ X[3]) / self.ncol).item().real
        return f"trX_1^2 = {trX1:.5f}, trX_4^2 = {trX4:.5f}. "

    def extra_config_lines(self) -> list[str]:
        return [f"  Coupling g               = {self.g}"]

    def run_metadata(self) -> dict[str, object]:
        meta = super().run_metadata()
        meta.update(
            {
                "has_source": self.source is not None,
                "model_variant": "type1",
            }
        )
        return meta
