Metadata-Version: 2.4
Name: MatrixModelHMC_pytorch
Version: 0.0.0
Summary: Hybrid Monte Carlo drivers for polarized IKKT-like matrix models
Requires-Python: >=3.9
Description-Content-Type: text/markdown
Requires-Dist: numpy
Requires-Dist: torch

# MatrixModelHMC_pytorch Hybrid Monte Carlo

Python/Torch implementation of Hybrid Monte Carlo for the polarized $D=4$ IKKT (IIB) matrix model (see [A. Martina, arXiv:2507.17813](https://arxiv.org/pdf/2507.17813)). The code cleanly separates the model-specific action and observables (the `models/` package) from the HMC integrator (`hmc.py`).

## Model

The four Hermitian matrices $X_I$ (with $I=1\ldots4$) and their fermionic partners $\psi$ are evolved with two supersymmetric mass deformations

**Type I, $SO(4)$ invariant, single coupling constant $g$**

$$
S_{D=4,\text{type I}}=\frac{1}{g}\text{Tr}\Bigl[-\frac14 [X_I,X_J]^2 -\frac{i}{2}\bar\psi \Gamma^I [X_I,\psi] + X_I^2 + \bar\psi\psi \Bigr]
$$

**Type II, $SO(3)$ invariant, two coupling constants $g$ and $\omega$**

$$
\begin{aligned}
S_{D=4,\text{type II}}=\frac{1}{g}\text{Tr}\Bigl[&-\frac14 [X_I,X_J]^2 -\frac{i}{2}\bar\psi \Gamma^I [X_I,\psi] + i \frac{2}{3}(1+\omega)\,\epsilon_{ijk} X_i X_j X_k \\
&+ \frac{1}{3}\left(\omega + \frac{2}{3}\right) X_i X_i + \frac{\omega}{3} X_4^2 - \frac{1}{3} \bar\psi \Gamma^{123} \psi \Bigr]
\end{aligned}
$$

In this codebase the couplings and mass-deformation choice are set via the CLI flags `--coupling` and `--model`. Use `--model pikkt4d_type1` for the Type I deformation (pass a single value to `--coupling`, interpreted as $g$) and `--model pikkt4d_type2` for Type II (two values to `--coupling`: first $g$, second $\omega$). A generic $D$-dimensional Yang-Mills model is also available via `--model yangmills`, where you can set the dimension with `--nmat`. You can register additional models in the `models/` package and select them at runtime via `--model`.

The package also includes a generic $D$-dimensional Yang-Mills matrix model (choose `--model yangmills`), whose action is $\frac{N}{g} \left(\sum_i \text{Tr}(X_i^2) - \frac14\sum_{ij} \text{Tr}([X_i,X_j]^2)\right)$.

## Setup

The project uses Python 3 with PyTorch. Ensure `torch` is installed with CUDA support if available; otherwise it will fall back to CPU (significantly slower for the polarized IKKT models. This is due to the $O(N^6)$ scaling of computing derivatives of the fermionic determinant. For pure bosonic models, CPU is actually faster because of the data transfer and kernel launch overheads). No extra dependencies are required beyond NumPy and Matplotlib for analysis.

## Usage

With this code, we can run $4D$ Polarized IKKT at $N=45$ with $400$ steps in under $2$ hours on `NVIDIA GeForce RTX 2080 Ti`.

Basic run (Type I, $N=10,\ g=100$). Outputs stored to `outputs/myRunName_pikkt4d_type1_g100.0_N10/`:

```bash
python main.py --model pikkt4d_type1 --ncol 10 --niters 300 --coupling 100.0 --fresh --name myRunName --data-path outputs
```

Type II with $N=10,\ \omega = 1$ and $g=100$ (note the double entry for `--coupling`):

```bash
python main.py --model pikkt4d_type2 --ncol 10 --niters 300 --coupling 100.0 1.0 --fresh --name myRunName --data-path outputs
```

$D$-dimensional Yang-Mills with $D=6$, $N=12$, and $g=50$:

```bash
python main.py --model yangmills --nmat 6 --ncol 12 --niters 200 --coupling 50.0 --fresh --name ymRun --data-path outputs
```

Resume from a checkpoint:

```bash
python main.py --resume --name myRunName --data-path outputs
```

Key flags (see `cli.py` for defaults):
- `--model NAME`: registered matrix model (required argument).
- `--ncol N`: matrix size \(N\).
- `--niters K`: HMC trajectories to run.
- `--step-size`, `--nsteps`: leapfrog integrator controls ($\Delta t$ and steps).
- `--coupling ...`: list of couplings (Type I expects a single $g$, Type II expects two values: $g$ and the ratio $\omega$).
- `--gpu`: uses gpu when available. defaults to cpu
- `--save`, `--save-every`: checkpoint cadence.
- `--data-path`: directory for outputs/checkpoints.
- `--seed`: RNG seed for deterministic runs.
- `--nmat`: number of matrices (dimension), overwritten for `--model pikkt4d_type2`, and `--model pikkt4d_type1`.
- **Type II options** (only meaningful when `--model pikkt4d_type2`): `--spin` (optional fuzzy-sphere background)

Outputs:
- Each run writes to `data_path/{name}_{model}_g{...}_N{...}/` and stores eigenvalues, correlators, checkpoints, and configuration metadata as `evals.npz`, `corrs.npz`, `checkpoint.pt`, and `metadata.json` inside that directory.

## Code structure

- `main.py` — CLI entry point, I/O, thermalization, and trajectory loop.
- `cli.py` — argument parsing and validation.
- `models/` — action, fermion determinants, observables, spin backgrounds (one file per model).
- `hmc.py` — model-agnostic leapfrog integrator and Metropolis step.
- `algebra.py` — Hermitian/traceless projections and adjoint actions.  
